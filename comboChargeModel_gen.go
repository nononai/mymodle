// Code generated by goctl. DO NOT EDIT!

package model

import (
	"context"
	"fmt"
	"time"

	"github.com/SpectatorNan/gorm-zero/gormc"
	"github.com/zeromicro/go-zero/core/stores/cache"
	"gorm.io/gorm"
)

var (
	cacheMinyunComboChargeIdPrefix = "cache:minyun:comboCharge:id:"
)

type (
	comboChargeModel interface {
		Insert(ctx context.Context, tx *gorm.DB, data *ComboCharge) error

		FindOne(ctx context.Context, id int64) (*ComboCharge, error)
		Update(ctx context.Context, tx *gorm.DB, data *ComboCharge) error

		Delete(ctx context.Context, tx *gorm.DB, id int64) error
		Transaction(ctx context.Context, fn func(db *gorm.DB) error) error
	}

	defaultComboChargeModel struct {
		gormc.CachedConn
		table string
	}

	ComboCharge struct {
		Id           int64          `gorm:"column:id"`
		ComboName    string         `gorm:"column:combo_name"`
		ComboType    int64          `gorm:"column:combo_type"` // 1,余额 2临时
		CostUnit     int64          `gorm:"column:cost_unit"`  // 1-60,计费单位
		SiteId       int64          `gorm:"column:site_id"`
		Context      string         `gorm:"column:context"`     // 计费内容，json
		Remark       string         `gorm:"column:remark"`      // 计费模板说明
		PowerFee     int64          `gorm:"column:power_fee"`   // 计量，一度多少钱
		ServiceFee   int64          `gorm:"column:service_fee"` // 计量，一小时多少钱服务费
		MinCost      int64          `gorm:"column:min_cost"`    // 最低消费金额
		CreatedAt    time.Time      `gorm:"column:created_at"`
		UpdatedAt    time.Time      `gorm:"column:updated_at"`
		DeletedAt    gorm.DeletedAt `gorm:"column:deleted_at;index"`
		CostType     int64          `gorm:"column:cost_type"`      // 1,计时2计次，3计量4，按时间阶梯
		TempIsRefund int64          `gorm:"column:temp_is_refund"` // 临时充点是否允许退费
		TempIsAuto   int64          `gorm:"column:temp_is_auto"`   // 临时充电是否允许充满自停
	}
)

func (ComboCharge) TableName() string {
	return "`combo_charge`"
}

func newComboChargeModel(conn *gorm.DB, c cache.CacheConf) *defaultComboChargeModel {
	return &defaultComboChargeModel{
		CachedConn: gormc.NewConn(conn, c),
		table:      "`combo_charge`",
	}
}

func (m *defaultComboChargeModel) Insert(ctx context.Context, tx *gorm.DB, data *ComboCharge) error {

	err := m.ExecCtx(ctx, func(conn *gorm.DB) error {
		db := conn
		if tx != nil {
			db = tx
		}
		return db.Save(&data).Error
	}, m.getCacheKeys(data)...)
	return err
}

func (m *defaultComboChargeModel) FindOne(ctx context.Context, id int64) (*ComboCharge, error) {
	minyunComboChargeIdKey := fmt.Sprintf("%s%v", cacheMinyunComboChargeIdPrefix, id)
	var resp ComboCharge
	err := m.QueryCtx(ctx, &resp, minyunComboChargeIdKey, func(conn *gorm.DB, v interface{}) error {
		return conn.Model(&ComboCharge{}).Where("`id` = ?", id).First(&resp).Error
	})
	switch err {
	case nil:
		return &resp, nil
	case gormc.ErrNotFound:
		return nil, ErrNotFound
	default:
		return nil, err
	}
}

func (m *defaultComboChargeModel) Update(ctx context.Context, tx *gorm.DB, data *ComboCharge) error {
	old, err := m.FindOne(ctx, data.Id)
	if err != nil && err != ErrNotFound {
		return err
	}
	err = m.ExecCtx(ctx, func(conn *gorm.DB) error {
		db := conn
		if tx != nil {
			db = tx
		}
		return db.Save(data).Error
	}, m.getCacheKeys(old)...)
	return err
}

func (m *defaultComboChargeModel) getCacheKeys(data *ComboCharge) []string {
	if data == nil {
		return []string{}
	}
	minyunComboChargeIdKey := fmt.Sprintf("%s%v", cacheMinyunComboChargeIdPrefix, data.Id)
	cacheKeys := []string{
		minyunComboChargeIdKey,
	}
	cacheKeys = append(cacheKeys, m.customCacheKeys(data)...)
	return cacheKeys
}

func (m *defaultComboChargeModel) Delete(ctx context.Context, tx *gorm.DB, id int64) error {
	data, err := m.FindOne(ctx, id)
	if err != nil {
		if err == ErrNotFound {
			return nil
		}
		return err
	}
	err = m.ExecCtx(ctx, func(conn *gorm.DB) error {
		db := conn
		if tx != nil {
			db = tx
		}
		return db.Delete(&ComboCharge{}, id).Error
	}, m.getCacheKeys(data)...)
	return err
}

func (m *defaultComboChargeModel) Transaction(ctx context.Context, fn func(db *gorm.DB) error) error {
	return m.TransactCtx(ctx, fn)
}

func (m *defaultComboChargeModel) formatPrimary(primary interface{}) string {
	return fmt.Sprintf("%s%v", cacheMinyunComboChargeIdPrefix, primary)
}

func (m *defaultComboChargeModel) queryPrimary(conn *gorm.DB, v, primary interface{}) error {
	return conn.Model(&ComboCharge{}).Where("`id` = ?", primary).Take(v).Error
}
